<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard - Análisis EEG Detección de Convulsiones</title>
    <!-- Plotly.js desde CDN -->
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background-color: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            color: #34495e;
            margin-top: 40px;
            border-left: 4px solid #3498db;
            padding-left: 15px;
        }
        .section {
            margin: 30px 0;
            padding: 20px;
            background-color: #fafafa;
            border-radius: 5px;
        }
        .plot-container {
            margin: 20px 0;
            padding: 15px;
            background-color: white;
            border-radius: 5px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .info-box {
            background-color: #e8f4f8;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
            border-left: 4px solid #3498db;
        }
        .metric {
            display: inline-block;
            margin: 10px 20px;
            padding: 10px 20px;
            background-color: #3498db;
            color: white;
            border-radius: 5px;
            font-weight: bold;
        }
        .metric-value {
            font-size: 1.5em;
        }
        .graph-info {
            margin: 20px 0;
            padding: 20px;
            background-color: #ffffff;
            border-left: 4px solid #3498db;
            border-radius: 5px;
        }
        .graph-title {
            font-size: 1.3em;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 15px;
        }
        .description {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
            line-height: 1.6;
        }
        .conclusion {
            background-color: #e8f5e9;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
            border-left: 4px solid #4caf50;
            line-height: 1.6;
        }
        .code-block {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 5px;
            margin: 15px 0;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            line-height: 1.5;
        }
        .code-block pre {
            margin: 0;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .code-comment {
            color: #75715e;
        }
        .code-keyword {
            color: #f92672;
        }
        .code-string {
            color: #e6db74;
        }
        .code-function {
            color: #66d9ef;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Dashboard - Análisis de Señales EEG para Detección de Convulsiones</h1>
        <div class="info-box">
            <strong>Pontificia Universidad Javeriana - Bogotá</strong><br>
            Procesamiento de Señales Biológicas<br>
            Realizado por: Felipe Rangel
        </div>

        <!-- Sección 1: Visualización Temporal -->
        <div class="section">
            <h2>1. Visualización de Señales en el Tiempo</h2>
            
            <!-- Gráfica Temporal Interictal -->
            <div class="graph-info">
                <div class="graph-title">Señal EEG - Segmento Interictal</div>
                
                <div class="description">
                    <strong>Descripción:</strong> Esta gráfica muestra la señal EEG en el dominio del tiempo para un segmento interictal (entre crisis epilépticas). La señal representa la actividad eléctrica del cerebro durante un período de actividad normal, sin convulsiones. Se observa la variación de amplitud de la señal a lo largo del tiempo, medida en microvoltios (μV).
                </div>
                
                <div class="conclusion">
                    <strong>Conclusión:</strong> La señal interictal muestra una actividad relativamente estable con variaciones de amplitud moderadas. No se observan patrones de alta amplitud o sincronización característicos de eventos convulsivos. Esta señal sirve como referencia para comparar con la actividad ictal.
                </div>
                
                <div class="code-block">
                    <pre># Código Python para visualización temporal interictal
import numpy as np
import matplotlib.pyplot as plt
import scipy.io

# Cargar datos del archivo .mat
mat_data = scipy.io.loadmat('ArchivoSeizureDetect.mat')
data_interictal = mat_data['Data_interictal']
fs = float(mat_data['Fs'][0, 0])  # Frecuencia de muestreo

# Seleccionar el primer segmento interictal
segmento_interictal = data_interictal[0, :]

# Crear vector de tiempo en segundos
n_muestras = len(segmento_interictal)
tiempo = np.arange(n_muestras) / fs

# Crear la gráfica
plt.figure(figsize=(12, 4))
plt.plot(tiempo, segmento_interictal, 'b-', linewidth=0.5)
plt.xlabel('Tiempo (s)', fontsize=12)
plt.ylabel('Amplitud (μV)', fontsize=12)
plt.title('Señal EEG - Segmento Interictal', fontsize=14, fontweight='bold')
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()</pre>
                </div>
            </div>
            
            <div class="plot-container">
                <div id="plot-temporal-interictal"></div>
            </div>
            
            <!-- Gráfica Temporal Ictal -->
            <div class="graph-info">
                <div class="graph-title">Señal EEG - Segmento Ictal</div>
                
                <div class="description">
                    <strong>Descripción:</strong> Esta gráfica muestra la señal EEG en el dominio del tiempo para un segmento ictal (durante una crisis epiléptica). La señal captura la actividad eléctrica anormal del cerebro caracterizada por descargas sincronizadas de alta amplitud y frecuencia. Esta actividad es distintiva y permite identificar eventos convulsivos.
                </div>
                
                <div class="conclusion">
                    <strong>Conclusión:</strong> La señal ictal presenta características claramente diferentes a la interictal: mayor amplitud, patrones más sincronizados y actividad de alta frecuencia. Estas diferencias son fundamentales para el desarrollo de algoritmos de detección automática de convulsiones.
                </div>
                
                <div class="code-block">
                    <pre># Código Python para visualización temporal ictal
import numpy as np
import matplotlib.pyplot as plt
import scipy.io

# Cargar datos del archivo .mat
mat_data = scipy.io.loadmat('ArchivoSeizureDetect.mat')
data_ictal = mat_data['Data_ictal']
fs = float(mat_data['Fs'][0, 0])  # Frecuencia de muestreo

# Seleccionar el primer segmento ictal
segmento_ictal = data_ictal[0, :]

# Crear vector de tiempo en segundos
n_muestras = len(segmento_ictal)
tiempo = np.arange(n_muestras) / fs

# Crear la gráfica
plt.figure(figsize=(12, 4))
plt.plot(tiempo, segmento_ictal, 'r-', linewidth=0.5)
plt.xlabel('Tiempo (s)', fontsize=12)
plt.ylabel('Amplitud (μV)', fontsize=12)
plt.title('Señal EEG - Segmento Ictal', fontsize=14, fontweight='bold')
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()</pre>
                </div>
            </div>
            
            <div class="plot-container">
                <div id="plot-temporal-ictal"></div>
            </div>
        </div>

        <!-- Sección 2: Espectrogramas Tiempo-Frecuencia -->
        <div class="section">
            <h2>2. Espectrogramas Tiempo-Frecuencia</h2>
            
            <!-- Espectrograma Interictal -->
            <div class="graph-info">
                <div class="graph-title">Espectrograma - Segmento Interictal</div>
                
                <div class="description">
                    <strong>Descripción:</strong> El espectrograma muestra la distribución de energía de la señal EEG en función del tiempo y la frecuencia para un segmento interictal. Utiliza la transformada de Fourier de tiempo corto (STFT) para analizar cómo varía el contenido espectral a lo largo del tiempo. Los colores representan la densidad espectral de potencia (PSD) en decibelios (dB), donde colores más intensos indican mayor energía en esa frecuencia y tiempo.
                </div>
                
                <div class="conclusion">
                    <strong>Conclusión:</strong> El espectrograma interictal muestra una distribución de energía relativamente uniforme a través de las diferentes bandas de frecuencia, sin concentraciones significativas de energía en bandas específicas. La actividad espectral es más dispersa y de menor intensidad comparada con la actividad ictal.
                </div>
                
                <div class="code-block">
                    <pre># Código Python para espectrograma interictal
import numpy as np
import matplotlib.pyplot as plt
from scipy import signal
import scipy.io

# Cargar datos del archivo .mat
mat_data = scipy.io.loadmat('ArchivoSeizureDetect.mat')
data_interictal = mat_data['Data_interictal']
fs = float(mat_data['Fs'][0, 0])  # Frecuencia de muestreo

# Seleccionar el primer segmento interictal
segmento_interictal = data_interictal[0, :]

# Calcular espectrograma usando el método de Welch
# nperseg: número de muestras por segmento
# noverlap: número de muestras que se solapan entre segmentos
nperseg = min(256, len(segmento_interictal) // 4)
noverlap = nperseg // 2
freqs, times, Sxx = signal.spectrogram(
    segmento_interictal, 
    fs, 
    nperseg=nperseg, 
    noverlap=noverlap, 
    window='hann'  # Ventana de Hann para suavizar
)

# Convertir a decibelios para mejor visualización
Sxx_db = 10 * np.log10(Sxx + 1e-10)  # Evitar log(0)

# Crear el espectrograma
plt.figure(figsize=(12, 6))
plt.pcolormesh(times, freqs, Sxx_db, shading='gouraud', cmap='viridis')
plt.colorbar(label='PSD (dB)')
plt.xlabel('Tiempo (s)', fontsize=12)
plt.ylabel('Frecuencia (Hz)', fontsize=12)
plt.title('Espectrograma - Segmento Interictal', fontsize=14, fontweight='bold')
plt.tight_layout()
plt.show()</pre>
                </div>
            </div>
            
            <div class="plot-container">
                <div id="plot-espectrograma-interictal"></div>
            </div>
            
            <!-- Espectrograma Ictal -->
            <div class="graph-info">
                <div class="graph-title">Espectrograma - Segmento Ictal</div>
                
                <div class="description">
                    <strong>Descripción:</strong> El espectrograma muestra la distribución de energía de la señal EEG durante un evento ictal (crisis epiléptica). Esta representación tiempo-frecuencia revela cómo la actividad espectral cambia durante la convulsión, mostrando concentraciones de energía en bandas de frecuencia específicas. Los patrones espectrales durante eventos ictales son característicos y diferentes a los observados en períodos interictales.
                </div>
                
                <div class="conclusion">
                    <strong>Conclusión:</strong> El espectrograma ictal muestra concentraciones significativas de energía, particularmente en las bandas de frecuencia más altas (beta y gamma). Se observan patrones más estructurados y sincronizados, con mayor intensidad espectral comparada con la actividad interictal. Estas características espectrales son clave para la detección automática de convulsiones.
                </div>
                
                <div class="code-block">
                    <pre># Código Python para espectrograma ictal
import numpy as np
import matplotlib.pyplot as plt
from scipy import signal
import scipy.io

# Cargar datos del archivo .mat
mat_data = scipy.io.loadmat('ArchivoSeizureDetect.mat')
data_ictal = mat_data['Data_ictal']
fs = float(mat_data['Fs'][0, 0])  # Frecuencia de muestreo

# Seleccionar el primer segmento ictal
segmento_ictal = data_ictal[0, :]

# Calcular espectrograma usando el método de Welch
# nperseg: número de muestras por segmento
# noverlap: número de muestras que se solapan entre segmentos
nperseg = min(256, len(segmento_ictal) // 4)
noverlap = nperseg // 2
freqs, times, Sxx = signal.spectrogram(
    segmento_ictal, 
    fs, 
    nperseg=nperseg, 
    noverlap=noverlap, 
    window='hann'  # Ventana de Hann para suavizar
)

# Convertir a decibelios para mejor visualización
Sxx_db = 10 * np.log10(Sxx + 1e-10)  # Evitar log(0)

# Crear el espectrograma
plt.figure(figsize=(12, 6))
plt.pcolormesh(times, freqs, Sxx_db, shading='gouraud', cmap='viridis')
plt.colorbar(label='PSD (dB)')
plt.xlabel('Tiempo (s)', fontsize=12)
plt.ylabel('Frecuencia (Hz)', fontsize=12)
plt.title('Espectrograma - Segmento Ictal', fontsize=14, fontweight='bold')
plt.tight_layout()
plt.show()</pre>
                </div>
            </div>
            
            <div class="plot-container">
                <div id="plot-espectrograma-ictal"></div>
            </div>
        </div>

        <!-- Sección 2.5: Visualización Multi-Canal -->
        <div class="section">
            <h2>2.5. Visualización Multi-Canal: Transición Interictal → Ictal</h2>
            
            <!-- Gráfica Multi-Canal -->
            <div class="graph-info">
                <div class="graph-title">Visualización Multi-Canal EEG: Transición Interictal → Ictal</div>
                
                <div class="description">
                    <strong>Descripción:</strong> Esta visualización muestra múltiples canales de EEG (16 canales) apilados verticalmente, representando la transición desde un estado interictal (entre crisis) hacia un estado ictal (durante la crisis epiléptica). Cada línea horizontal representa un canal diferente de la señal EEG. La parte izquierda de cada canal (en azul) muestra la actividad interictal, caracterizada por amplitudes relativamente bajas y patrones irregulares. La parte derecha (en marrón) muestra la actividad ictal, con amplitudes significativamente mayores y patrones más rítmicos y sincronizados. La línea roja punteada vertical marca el punto de transición entre ambos estados. Esta visualización es similar a las representaciones clínicas estándar de EEG y permite observar claramente las diferencias entre ambos estados fisiológicos.
                </div>
                
                <div class="conclusion">
                    <strong>Conclusión:</strong> La visualización multi-canal revela de manera clara y simultánea las diferencias entre los estados interictal e ictal a través de múltiples canales. Se observa una transición abrupta y sincronizada en todos los canales, donde la actividad ictal muestra amplitudes dramáticamente aumentadas y patrones más estructurados. Esta representación es fundamental para el diagnóstico clínico y demuestra visualmente por qué las características extraídas (especialmente las relacionadas con amplitud y contenido espectral) son efectivas para la clasificación automática de convulsiones.
                </div>
                
                <div class="code-block">
                    <pre># Código Python para visualización multi-canal EEG
import numpy as np
import matplotlib.pyplot as plt
import scipy.io

def crear_visualizacion_multicanal(data_ictal, data_interictal, fs, n_canales=16):
    """
    Crea una visualización multi-canal mostrando la transición interictal-ictal
    
    Args:
        data_ictal: Array con eventos ictal (n_eventos, n_muestras)
        data_interictal: Array con eventos interictal (n_eventos, n_muestras)
        fs: Frecuencia de muestreo
        n_canales: Número de canales a mostrar (default 16)
    """
    # Seleccionar n_canales eventos de cada tipo
    n_canales = min(n_canales, min(data_interictal.shape[0], data_ictal.shape[0]))
    indices_interictal = np.linspace(0, data_interictal.shape[0]-1, n_canales, dtype=int)
    indices_ictal = np.linspace(0, data_ictal.shape[0]-1, n_canales, dtype=int)
    
    # Crear vector de tiempo para cada segmento
    n_muestras = data_interictal.shape[1]
    tiempo_segmento = np.arange(n_muestras) / fs
    
    # Concatenar interictal seguido de ictal para cada canal
    tiempo_completo = np.concatenate([
        tiempo_segmento, 
        tiempo_segmento + tiempo_segmento[-1] + tiempo_segmento[1]
    ])
    
    # Preparar datos para cada canal
    offset_vertical = 0
    spacing = 500  # Espaciado vertical entre canales
    
    # Crear la figura
    fig, ax = plt.subplots(figsize=(16, 10))
    
    for i in range(n_canales):
        # Obtener segmentos
        seg_interictal = data_interictal[indices_interictal[i], :]
        seg_ictal = data_ictal[indices_ictal[i], :]
        
        # Crear tiempos para cada segmento
        tiempo_interictal = tiempo_segmento
        tiempo_ictal = tiempo_segmento + tiempo_segmento[-1] + tiempo_segmento[1]
        
        # Añadir offset vertical y graficar
        senal_interictal_offset = seg_interictal + offset_vertical
        senal_ictal_offset = seg_ictal + offset_vertical
        
        # Graficar segmento interictal en azul
        ax.plot(tiempo_interictal, senal_interictal_offset, 
               'b-', linewidth=0.8, alpha=0.8)
        
        # Graficar segmento ictal en marrón
        ax.plot(tiempo_ictal, senal_ictal_offset, 
               color='#8B4513', linewidth=0.8, alpha=0.8)  # Color marrón
        
        offset_vertical -= spacing
    
    # Añadir línea vertical en el punto de transición
    tiempo_transicion = tiempo_segmento[-1] + tiempo_segmento[1]
    y_min = offset_vertical - spacing
    y_max = spacing * (n_canales - 1)
    ax.axvline(x=tiempo_transicion, color='red', linestyle='--', 
              linewidth=2, label='Transición')
    
    # Añadir etiquetas de regiones
    ax.text(tiempo_transicion / 2, y_max - 200, 'Interictal', 
           fontsize=14, color='blue', fontweight='bold', 
           ha='center', bbox=dict(boxstyle='round', facecolor='white', 
                                 edgecolor='blue', linewidth=2))
    ax.text(tiempo_transicion + (tiempo_transicion / 2), y_max - 200, 'Ictal', 
           fontsize=14, color='#8B4513', fontweight='bold', 
           ha='center', bbox=dict(boxstyle='round', facecolor='white', 
                                 edgecolor='#8B4513', linewidth=2))
    
    # Configurar ejes
    ax.set_xlabel('Tiempo (s)', fontsize=12)
    ax.set_ylabel('Amplitud (μV) - Canales apilados', fontsize=12)
    ax.set_title('Visualización Multi-Canal EEG: Transición Interictal → Ictal', 
                fontsize=14, fontweight='bold')
    ax.grid(True, alpha=0.3)
    ax.legend(loc='upper right')
    
    plt.tight_layout()
    plt.show()

# Cargar datos
mat_data = scipy.io.loadmat('ArchivoSeizureDetect.mat')
data_ictal = mat_data['Data_ictal']
data_interictal = mat_data['Data_interictal']
fs = float(mat_data['Fs'][0, 0])

# Crear visualización
crear_visualizacion_multicanal(data_ictal, data_interictal, fs, n_canales=16)</pre>
                </div>
            </div>
            
            <div class="plot-container">
                <div id="plot-multicanal"></div>
            </div>
        </div>

        <!-- Sección 3: Matriz de Características -->
        <div class="section">
            <h2>3. Matriz de Características</h2>
            
            <div class="info-box">
                <strong>Nota:</strong> Cada característica se muestra en una gráfica individual para permitir una mejor visualización de las diferencias entre estados interictal e ictal, evitando que características con valores grandes (como Variance) dominen la escala visual.
            </div>
            
            <!-- Gráfica de Características - Descripción General -->
            <div class="graph-info">
                <div class="graph-title">Comparación de Características: Interictal vs Ictal</div>
                
                <div class="description">
                    <strong>Descripción:</strong> Las siguientes gráficas muestran las 7 características extraídas de todos los eventos EEG, comparando las clases interictal e ictal. Cada característica se presenta en una gráfica individual con su propia escala, lo que permite visualizar mejor las diferencias sin que características con valores grandes dominen la visualización. Las características incluyen: media (mean), varianza (variance), y densidad espectral de potencia (PSD) en las bandas delta (0.5-4 Hz), theta (4-8 Hz), alpha (8-13 Hz), beta (13-30 Hz) y gamma (30-100 Hz). Las barras muestran los valores promedio y las líneas de error representan la desviación estándar.
                </div>
                
                <div class="conclusion">
                    <strong>Conclusión:</strong> Al visualizar cada característica de manera individual, se pueden observar claramente las diferencias entre estados interictal e ictal. Las características espectrales (PSD en diferentes bandas) muestran variaciones importantes, especialmente en las bandas de mayor frecuencia (beta y gamma), donde los eventos ictales presentan mayor energía. Estas diferencias justifican el uso de estas características para la clasificación automática de convulsiones.
                </div>
            </div>
            
            <!-- Código Python -->
            <div class="graph-info">
                <div class="code-block">
                    <pre># Código Python para matriz de características y comparación
import numpy as np
import matplotlib.pyplot as plt
from scipy import signal
import scipy.io

# Definir bandas de frecuencia EEG estándar
BANDAS_FRECUENCIA = {{
    'delta': (0.5, 4),
    'theta': (4, 8),
    'alpha': (8, 13),
    'beta': (13, 30),
    'gamma': (30, 100)
}}

def calcular_psd_banda(senal, fs, banda_min, banda_max):
    """
    Calcula la densidad espectral de potencia (PSD) promedio en una banda
    """
    freqs, psd = signal.welch(senal, fs, nperseg=min(256, len(senal)), 
                              noverlap=None, nfft=None)
    idx_banda = np.where((freqs >= banda_min) & (freqs <= banda_max))[0]
    if len(idx_banda) > 0:
        psd_banda = np.mean(psd[idx_banda])
    else:
        psd_banda = 0.0
    return psd_banda

def extraer_caracteristicas(senal):
    """
    Extrae las 7 características de un segmento de señal
    """
    fs = 500.0
    mean_val = np.mean(senal)
    variance_val = np.var(senal)
    psd_delta = calcular_psd_banda(senal, fs, BANDAS_FRECUENCIA['delta'][0], 
                                    BANDAS_FRECUENCIA['delta'][1])
    psd_theta = calcular_psd_banda(senal, fs, BANDAS_FRECUENCIA['theta'][0], 
                                    BANDAS_FRECUENCIA['theta'][1])
    psd_alpha = calcular_psd_banda(senal, fs, BANDAS_FRECUENCIA['alpha'][0], 
                                    BANDAS_FRECUENCIA['alpha'][1])
    psd_beta = calcular_psd_banda(senal, fs, BANDAS_FRECUENCIA['beta'][0], 
                                   BANDAS_FRECUENCIA['beta'][1])
    psd_gamma = calcular_psd_banda(senal, fs, BANDAS_FRECUENCIA['gamma'][0], 
                                   BANDAS_FRECUENCIA['gamma'][1])
    return np.array([mean_val, variance_val, psd_delta, psd_theta, 
                     psd_alpha, psd_beta, psd_gamma])

# Cargar datos
mat_data = scipy.io.loadmat('ArchivoSeizureDetect.mat')
data_ictal = mat_data['Data_ictal']
data_interictal = mat_data['Data_interictal']

# Extraer características de todos los eventos
caracteristicas_interictal = []
caracteristicas_ictal = []

for i in range(data_interictal.shape[0]):
    caracteristicas_interictal.append(extraer_caracteristicas(data_interictal[i, :]))

for i in range(data_ictal.shape[0]):
    caracteristicas_ictal.append(extraer_caracteristicas(data_ictal[i, :]))

caracteristicas_interictal = np.array(caracteristicas_interictal)
caracteristicas_ictal = np.array(caracteristicas_ictal)

# Calcular promedios y desviaciones estándar
mean_interictal = caracteristicas_interictal.mean(axis=0)
std_interictal = caracteristicas_interictal.std(axis=0)
mean_ictal = caracteristicas_ictal.mean(axis=0)
std_ictal = caracteristicas_ictal.std(axis=0)

# Nombres de las características
nombres = ['Mean', 'Variance', 'PSD Delta', 'PSD Theta', 
           'PSD Alpha', 'PSD Beta', 'PSD Gamma']

# Crear gráfica individual para cada característica
for i, nombre in enumerate(nombres):
    fig, ax = plt.subplots(figsize=(8, 5))
    
    x = ['Interictal', 'Ictal']
    y = [mean_interictal[i], mean_ictal[i]]
    yerr = [std_interictal[i], std_ictal[i]]
    colors = ['blue', 'red']
    
    bars = ax.bar(x, y, yerr=yerr, color=colors, alpha=0.7, capsize=10, width=0.6)
    ax.set_ylabel('Valor', fontsize=12)
    ax.set_title(f'{{nombre}}: Comparación Interictal vs Ictal', 
                fontsize=14, fontweight='bold')
    ax.grid(True, alpha=0.3, axis='y')
    plt.tight_layout()
    plt.show()</pre>
                </div>
            </div>
            
            <!-- Gráficas individuales para cada característica -->
            <div class="plot-container">
                <div id="plot-caracteristica-mean"></div>
            </div>
            
            <div class="plot-container">
                <div id="plot-caracteristica-variance"></div>
            </div>
            
            <div class="plot-container">
                <div id="plot-caracteristica-psd-delta"></div>
            </div>
            
            <div class="plot-container">
                <div id="plot-caracteristica-psd-theta"></div>
            </div>
            
            <div class="plot-container">
                <div id="plot-caracteristica-psd-alpha"></div>
            </div>
            
            <div class="plot-container">
                <div id="plot-caracteristica-psd-beta"></div>
            </div>
            
            <div class="plot-container">
                <div id="plot-caracteristica-psd-gamma"></div>
            </div>
        </div>

        <!-- Sección 4: Resultados de Clasificación -->
        <div class="section">
            <h2>4. Resultados de Clasificación con SVM</h2>
            
            <div class="info-box">
                <div class="metric">
                    <div>Precisión (Accuracy)</div>
                    <div class="metric-value" id="accuracy-value">-</div>
                </div>
                <div class="metric">
                    <div>Datos de Entrenamiento</div>
                    <div class="metric-value" id="train-size">-</div>
                </div>
                <div class="metric">
                    <div>Datos de Prueba</div>
                    <div class="metric-value" id="test-size">-</div>
                </div>
            </div>
            
            <!-- Matriz de Confusión -->
            <div class="graph-info">
                <div class="graph-title">Matriz de Confusión</div>
                
                <div class="description">
                    <strong>Descripción:</strong> La matriz de confusión muestra el rendimiento del clasificador SVM comparando las predicciones del modelo con los valores reales de las etiquetas. La matriz es una tabla de 2x2 donde las filas representan las clases reales (Interictal e Ictal) y las columnas representan las clases predichas. Los valores en la diagonal principal (verdaderos positivos y verdaderos negativos) indican clasificaciones correctas, mientras que los valores fuera de la diagonal (falsos positivos y falsos negativos) indican errores de clasificación.
                </div>
                
                <div class="conclusion">
                    <strong>Conclusión:</strong> El clasificador SVM muestra un buen rendimiento con una precisión del 88.57%. La matriz de confusión revela que el modelo tiene una alta capacidad para identificar correctamente eventos interictales (21/21 correctos), mientras que tiene algunas dificultades con eventos ictales (10/14 correctos, 4 falsos negativos). Esto sugiere que el modelo es más conservador en la detección de convulsiones, lo cual puede ser preferible en aplicaciones clínicas para evitar falsas alarmas.
                </div>
                
                <div class="code-block">
                    <pre># Código Python para matriz de confusión
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.svm import SVC
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import confusion_matrix
import matplotlib.pyplot as plt
import seaborn as sns

# Cargar datos procesados
# (asumiendo que ya se tienen las características y etiquetas)
# matriz_caracteristicas: array (n_eventos, 7)
# etiquetas: array (n_eventos,) con 0=interictal, 1=ictal

# Dividir datos en training y testing (80/20)
X_train, X_test, y_train, y_test = train_test_split(
    matriz_caracteristicas, 
    etiquetas, 
    test_size=0.2, 
    random_state=42, 
    stratify=etiquetas  # Mantener proporción de clases
)

# Normalizar características
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

# Entrenar clasificador SVM
clf = SVC(kernel='rbf', C=1.0, gamma='scale', random_state=42)
clf.fit(X_train_scaled, y_train)

# Realizar predicciones
y_pred = clf.predict(X_test_scaled)

# Calcular matriz de confusión
cm = confusion_matrix(y_test, y_pred)

# Crear visualización de la matriz de confusión
plt.figure(figsize=(8, 6))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', 
            xticklabels=['Interictal', 'Ictal'],
            yticklabels=['Interictal', 'Ictal'],
            cbar_kws={'label': 'Cantidad'})
plt.xlabel('Predicción', fontsize=12)
plt.ylabel('Valor Real', fontsize=12)
plt.title('Matriz de Confusión', fontsize=14, fontweight='bold')
plt.tight_layout()
plt.show()</pre>
                </div>
            </div>
            
            <div class="plot-container">
                <div id="plot-confusion-matrix"></div>
            </div>
            
            <!-- Métricas de Clasificación -->
            <div class="graph-info">
                <div class="graph-title">Métricas de Clasificación por Clase</div>
                
                <div class="description">
                    <strong>Descripción:</strong> Esta gráfica muestra las métricas de rendimiento del clasificador SVM para cada clase (Interictal e Ictal). Las métricas incluyen: Precision (precisión), que mide la proporción de predicciones positivas que fueron correctas; Recall (sensibilidad), que mide la proporción de casos positivos reales que fueron identificados correctamente; y F1-Score, que es la media armónica de precision y recall, proporcionando una medida balanceada del rendimiento. Estas métricas permiten evaluar el rendimiento del modelo de manera más detallada que solo la precisión global.
                </div>
                
                <div class="conclusion">
                    <strong>Conclusión:</strong> El análisis de métricas muestra que el clasificador tiene un excelente rendimiento para la clase Interictal (precision=0.84, recall=1.00, F1=0.91), indicando que casi todos los eventos interictales son identificados correctamente. Para la clase Ictal, el modelo tiene precision perfecta (1.00) pero recall moderado (0.71), lo que significa que cuando predice un evento ictal, siempre es correcto, pero no detecta todos los eventos ictales. El F1-Score de 0.83 para Ictal indica un buen balance general. Estas métricas confirman que el modelo es adecuado para aplicaciones de detección de convulsiones.
                </div>
                
                <div class="code-block">
                    <pre># Código Python para métricas de clasificación
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.svm import SVC
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import classification_report, precision_score, recall_score, f1_score
import matplotlib.pyplot as plt

# Cargar datos procesados
# (asumiendo que ya se tienen las características y etiquetas)
# matriz_caracteristicas: array (n_eventos, 7)
# etiquetas: array (n_eventos,) con 0=interictal, 1=ictal

# Dividir datos en training y testing (80/20)
X_train, X_test, y_train, y_test = train_test_split(
    matriz_caracteristicas, 
    etiquetas, 
    test_size=0.2, 
    random_state=42, 
    stratify=etiquetas
)

# Normalizar características
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

# Entrenar clasificador SVM
clf = SVC(kernel='rbf', C=1.0, gamma='scale', random_state=42)
clf.fit(X_train_scaled, y_train)

# Realizar predicciones
y_pred = clf.predict(X_test_scaled)

# Calcular métricas por clase
precision_interictal = precision_score(y_test, y_pred, pos_label=0)
recall_interictal = recall_score(y_test, y_pred, pos_label=0)
f1_interictal = f1_score(y_test, y_pred, pos_label=0)

precision_ictal = precision_score(y_test, y_pred, pos_label=1)
recall_ictal = recall_score(y_test, y_pred, pos_label=1)
f1_ictal = f1_score(y_test, y_pred, pos_label=1)

# Preparar datos para gráfica
clases = ['Interictal', 'Ictal']
precision = [precision_interictal, precision_ictal]
recall = [recall_interictal, recall_ictal]
f1 = [f1_interictal, f1_ictal]

# Crear gráfica de barras
x = np.arange(len(clases))
width = 0.25

fig, ax = plt.subplots(figsize=(10, 6))
bars1 = ax.bar(x - width, precision, width, label='Precision', color='green', alpha=0.7)
bars2 = ax.bar(x, recall, width, label='Recall', color='orange', alpha=0.7)
bars3 = ax.bar(x + width, f1, width, label='F1-Score', color='purple', alpha=0.7)

ax.set_xlabel('Clase', fontsize=12)
ax.set_ylabel('Valor', fontsize=12)
ax.set_title('Métricas de Clasificación por Clase', fontsize=14, fontweight='bold')
ax.set_xticks(x)
ax.set_xticklabels(clases)
ax.set_ylim([0, 1.1])
ax.legend()
ax.grid(True, alpha=0.3, axis='y')
plt.tight_layout()
plt.show()

# Imprimir reporte completo
print(classification_report(y_test, y_pred, target_names=['Interictal', 'Ictal']))</pre>
                </div>
            </div>
            
            <div class="plot-container">
                <div id="plot-metricas"></div>
            </div>
        </div>
    </div>

    <script>
        // Cargar datos del archivo JSON
        let datosDashboard = null;

        // Función para cargar los datos
        async function cargarDatos() {
            try {
                const response = await fetch('datos_dashboard.json');
                datosDashboard = await response.json();
                inicializarDashboard();
            } catch (error) {
                console.error('Error al cargar datos:', error);
                alert('Error al cargar los datos. Asegúrese de que el archivo datos_dashboard.json esté en el mismo directorio.');
            }
        }

        // Función principal que inicializa todos los gráficos
        function inicializarDashboard() {
            // 1. Gráficas temporales
            crearGraficaTemporal('plot-temporal-interictal', 
                                datosDashboard.visualizacion.tiempo_interictal,
                                datosDashboard.visualizacion.senal_interictal,
                                'Señal EEG - Segmento Interictal',
                                'blue');
            
            crearGraficaTemporal('plot-temporal-ictal',
                                datosDashboard.visualizacion.tiempo_ictal,
                                datosDashboard.visualizacion.senal_ictal,
                                'Señal EEG - Segmento Ictal',
                                'red');

            // 2. Espectrogramas
            crearEspectrograma('plot-espectrograma-interictal',
                              datosDashboard.visualizacion.times_interictal,
                              datosDashboard.visualizacion.freqs_interictal,
                              datosDashboard.visualizacion.Sxx_interictal,
                              'Espectrograma - Segmento Interictal');

            crearEspectrograma('plot-espectrograma-ictal',
                              datosDashboard.visualizacion.times_ictal,
                              datosDashboard.visualizacion.freqs_ictal,
                              datosDashboard.visualizacion.Sxx_ictal,
                              'Espectrograma - Segmento Ictal');

            // 3. Matriz de características - Gráficas individuales
            crearGraficasCaracteristicasIndividuales(datosDashboard.caracteristicas.nombres,
                                                     datosDashboard.caracteristicas.estadisticas);

            // 3.5. Visualización multi-canal
            if (datosDashboard.visualizacion.multicanal) {
                crearVisualizacionMulticanal('plot-multicanal',
                                            datosDashboard.visualizacion.multicanal);
            }

            // 4. Resultados de clasificación
            mostrarMetricasClasificacion(datosDashboard.clasificacion);
            crearMatrizConfusion('plot-confusion-matrix',
                                datosDashboard.clasificacion.confusion_matrix);
            crearGraficaMetricas('plot-metricas',
                                datosDashboard.clasificacion.classification_report);
        }

        // Función para crear gráfica temporal
        function crearGraficaTemporal(divId, tiempo, senal, titulo, color) {
            const trace = {
                x: tiempo,
                y: senal,
                type: 'scatter',
                mode: 'lines',
                line: { color: color, width: 1 },
                name: 'Señal EEG'
            };

            const layout = {
                title: {
                    text: titulo,
                    font: { size: 18 }
                },
                xaxis: {
                    title: 'Tiempo (s)',
                    titlefont: { size: 14 }
                },
                yaxis: {
                    title: 'Amplitud (μV)',
                    titlefont: { size: 14 }
                },
                hovermode: 'closest',
                margin: { l: 60, r: 30, t: 50, b: 50 }
            };

            Plotly.newPlot(divId, [trace], layout, {responsive: true});
        }

        // Función para crear espectrograma
        function crearEspectrograma(divId, times, freqs, Sxx, titulo) {
            // Convertir arrays anidados a arrays 2D si es necesario
            let SxxArray = Sxx;
            if (Array.isArray(Sxx[0]) && !Array.isArray(Sxx[0][0])) {
                // Si Sxx es una lista de listas, ya está bien
                SxxArray = Sxx;
            }

            const trace = {
                x: times,
                y: freqs,
                z: SxxArray,
                type: 'heatmap',
                colorscale: 'Viridis',
                colorbar: {
                    title: 'PSD (dB)',
                    titleside: 'right'
                }
            };

            const layout = {
                title: {
                    text: titulo,
                    font: { size: 18 }
                },
                xaxis: {
                    title: 'Tiempo (s)',
                    titlefont: { size: 14 }
                },
                yaxis: {
                    title: 'Frecuencia (Hz)',
                    titlefont: { size: 14 }
                },
                margin: { l: 60, r: 30, t: 50, b: 50 }
            };

            Plotly.newPlot(divId, [trace], layout, {responsive: true});
        }

        // Función para crear visualización multi-canal
        function crearVisualizacionMulticanal(divId, datosMulticanal) {
            const traces = [];
            const tiempoTransicion = datosMulticanal.tiempo_transicion;
            
            // Crear un trace para cada canal
            datosMulticanal.canales.forEach((canal, index) => {
                // Trace para segmento interictal (azul)
                traces.push({
                    x: canal.tiempo_interictal,
                    y: canal.senal_interictal.map(val => val + canal.offset),
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: 'blue', width: 0.8 },
                    name: index === 0 ? 'Interictal' : '',
                    showlegend: index === 0,
                    hoverinfo: 'skip'
                });
                
                // Trace para segmento ictal (rojo/marrón)
                traces.push({
                    x: canal.tiempo_ictal,
                    y: canal.senal_ictal.map(val => val + canal.offset),
                    type: 'scatter',
                    mode: 'lines',
                    line: { color: '#8B4513', width: 0.8 }, // Color marrón
                    name: index === 0 ? 'Ictal' : '',
                    showlegend: index === 0,
                    hoverinfo: 'skip'
                });
            });
            
            // Añadir línea vertical en el punto de transición
            const yMin = Math.min(...datosMulticanal.canales.map(c => c.offset - 500));
            const yMax = Math.max(...datosMulticanal.canales.map(c => c.offset + 500));
            
            traces.push({
                x: [tiempoTransicion, tiempoTransicion],
                y: [yMin, yMax],
                type: 'scatter',
                mode: 'lines',
                line: { color: 'red', width: 2, dash: 'dash' },
                name: 'Transición',
                showlegend: true,
                hoverinfo: 'skip'
            });
            
            const layout = {
                title: {
                    text: 'Visualización Multi-Canal EEG: Transición Interictal → Ictal',
                    font: { size: 18 }
                },
                xaxis: {
                    title: 'Tiempo (s)',
                    titlefont: { size: 14 },
                    showgrid: true,
                    gridcolor: 'rgba(128,128,128,0.2)'
                },
                yaxis: {
                    title: 'Amplitud (μV) - Canales apilados',
                    titlefont: { size: 14 },
                    showgrid: true,
                    gridcolor: 'rgba(128,128,128,0.2)',
                    showticklabels: false  // Ocultar valores del eje Y para mejor visualización
                },
                hovermode: 'closest',
                margin: { l: 60, r: 30, t: 50, b: 50 },
                legend: {
                    x: 0.02,
                    y: 0.98,
                    bgcolor: 'rgba(255,255,255,0.8)'
                },
                annotations: [
                    {
                        x: tiempoTransicion / 2,
                        y: yMax - 200,
                        text: 'Interictal',
                        showarrow: false,
                        font: { size: 14, color: 'blue', bold: true },
                        bgcolor: 'rgba(255,255,255,0.7)',
                        bordercolor: 'blue',
                        borderwidth: 2
                    },
                    {
                        x: tiempoTransicion + (tiempoTransicion / 2),
                        y: yMax - 200,
                        text: 'Ictal',
                        showarrow: false,
                        font: { size: 14, color: '#8B4513', bold: true },
                        bgcolor: 'rgba(255,255,255,0.7)',
                        bordercolor: '#8B4513',
                        borderwidth: 2
                    }
                ]
            };
            
            Plotly.newPlot(divId, traces, layout, {responsive: true});
        }

        // Función para crear gráficas individuales de características
        function crearGraficasCaracteristicasIndividuales(nombres, estadisticas) {
            // IDs de los contenedores para cada característica
            const ids = [
                'plot-caracteristica-mean',
                'plot-caracteristica-variance',
                'plot-caracteristica-psd-delta',
                'plot-caracteristica-psd-theta',
                'plot-caracteristica-psd-alpha',
                'plot-caracteristica-psd-beta',
                'plot-caracteristica-psd-gamma'
            ];
            
            nombres.forEach((nombre, index) => {
                const traceInterictal = {
                    x: ['Interictal'],
                    y: [estadisticas.interictal.mean[index]],
                    type: 'bar',
                    name: 'Interictal',
                    marker: { color: 'blue' },
                    error_y: {
                        type: 'data',
                        array: [estadisticas.interictal.std[index]],
                        visible: true
                    },
                    width: 0.5
                };

                const traceIctal = {
                    x: ['Ictal'],
                    y: [estadisticas.ictal.mean[index]],
                    type: 'bar',
                    name: 'Ictal',
                    marker: { color: 'red' },
                    error_y: {
                        type: 'data',
                        array: [estadisticas.ictal.std[index]],
                        visible: true
                    },
                    width: 0.5
                };

                const layout = {
                    title: {
                        text: nombre + ': Comparación Interictal vs Ictal',
                        font: { size: 16 }
                    },
                    xaxis: {
                        title: 'Estado',
                        titlefont: { size: 14 }
                    },
                    yaxis: {
                        title: 'Valor',
                        titlefont: { size: 14 }
                    },
                    barmode: 'group',
                    margin: { l: 60, r: 30, t: 50, b: 50 },
                    legend: { x: 0.7, y: 0.95 },
                    showlegend: true
                };

                Plotly.newPlot(ids[index], [traceInterictal, traceIctal], layout, {responsive: true});
            });
        }

        // Función para mostrar métricas de clasificación
        function mostrarMetricasClasificacion(resultados) {
            document.getElementById('accuracy-value').textContent = 
                (resultados.accuracy * 100).toFixed(2) + '%';
            document.getElementById('train-size').textContent = resultados.n_train;
            document.getElementById('test-size').textContent = resultados.n_test;
        }

        // Función para crear matriz de confusión
        function crearMatrizConfusion(divId, confusionMatrix) {
            const z = confusionMatrix;
            const x = ['Interictal', 'Ictal'];
            const y = ['Interictal', 'Ictal'];

            const trace = {
                x: x,
                y: y,
                z: z,
                type: 'heatmap',
                colorscale: 'Blues',
                text: z.map(row => row.map(val => val.toString())),
                texttemplate: '%{text}',
                textfont: { size: 16, color: 'white' },
                showscale: true,
                colorbar: {
                    title: 'Cantidad',
                    titleside: 'right'
                }
            };

            const layout = {
                title: {
                    text: 'Matriz de Confusión',
                    font: { size: 18 }
                },
                xaxis: {
                    title: 'Predicción',
                    titlefont: { size: 14 }
                },
                yaxis: {
                    title: 'Valor Real',
                    titlefont: { size: 14 }
                },
                margin: { l: 80, r: 30, t: 50, b: 50 }
            };

            Plotly.newPlot(divId, [trace], layout, {responsive: true});
        }

        // Función para crear gráfica de métricas
        function crearGraficaMetricas(divId, report) {
            const clases = ['Interictal', 'Ictal'];
            const precision = [
                report['Interictal'].precision,
                report['Ictal'].precision
            ];
            const recall = [
                report['Interictal'].recall,
                report['Ictal'].recall
            ];
            const f1 = [
                report['Interictal']['f1-score'],
                report['Ictal']['f1-score']
            ];

            const trace1 = {
                x: clases,
                y: precision,
                type: 'bar',
                name: 'Precision',
                marker: { color: 'green' }
            };

            const trace2 = {
                x: clases,
                y: recall,
                type: 'bar',
                name: 'Recall',
                marker: { color: 'orange' }
            };

            const trace3 = {
                x: clases,
                y: f1,
                type: 'bar',
                name: 'F1-Score',
                marker: { color: 'purple' }
            };

            const layout = {
                title: {
                    text: 'Métricas de Clasificación por Clase',
                    font: { size: 18 }
                },
                xaxis: {
                    title: 'Clase',
                    titlefont: { size: 14 }
                },
                yaxis: {
                    title: 'Valor',
                    titlefont: { size: 14 },
                    range: [0, 1.1]
                },
                barmode: 'group',
                margin: { l: 60, r: 30, t: 50, b: 50 },
                legend: { x: 0.7, y: 0.95 }
            };

            Plotly.newPlot(divId, [trace1, trace2, trace3], layout, {responsive: true});
        }

        // Inicializar dashboard al cargar la página
        cargarDatos();
    </script>
</body>
</html>

